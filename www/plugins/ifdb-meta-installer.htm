<html>
<head>
   <title>IFDB Download Adviser and Meta Installer</title>
   <style type="text/css">

body {
    background: #ffffff;
    font:  11pt/140% Verdana, Arial, Helvetica, Sans-Serif;
    color: #000000;
    line-height: 1.4;
}
h1 {
    font:  125% Verdana, Arial, Helvetica, Sans-Serif;
    font-weight: bold;
    color: #000080;
}
h2 {
    font-size: 110%;
    font-weight: bold;
    color: #000080;
}
h3 {
    font-size: 100%;
    font-weight: bold;
    color: #000080;
    margin-bottom: 0px;
}
ol li, ul li {
    margin-top: 1em;
    margin-bottom: 1em;
}
ul.tight li, ol.tight li {
    margin-top: 0;
    margin-bottom: 0;
}


   </style>
</head>
<body>

<h1>IFDB Download Adviser and Meta Installer</h1>

<p><i>Mike Roberts<br>
   August, 2009<br>
   Original version: September, 2007<br>
</i>

<h2>Executive Summary</h2>

<p>I've designed a new web-based system to provide users with
customized installation instructions for the interpreter software
required to play virtually any IF game.  The custom instruction
generator is called the <b>Download Adviser</b>.  The system is
designed to work with any IF interpreter system that follows the
typical VM/interpreter design (namely, a format for distributing game
files, and an interpreter program to play them), as well as with games
packaged as native applications.

<p>The goal is to make IFDB a one-stop shopping site for IF downloads.
That is, IFDB should link <b>directly</b> to everything you need to
play a given game - the game file, the interpreter engine, and any
ZIP-type extractor tool.  We don't merely give users links to other
sites where they can find these tools; we'll actually give them direct
download links to every bit of software they need, along with
instructions to install it all, <b>all on a single page</b>.

<p>The system also supports an even more automatic system called the
<b>Meta Installer</b>.  This is an optional client/server component,
optional in two senses: it's optional for the OS point person to
provide it at all for their OS, and it's optional for users to use,
because it requires a download to the client machine.  This currently
exists on Windows in exactly the form described in this document; it's
a browser plug-in that provides a button on each IFDB game page that
completely automates the entire download and install process - it's
basically a "Click to Play" button.  Similar functionality is
available on the Mac in the form of Andrew Hunter's Zoom multi-format
IF player.  Zoom has a feature for browsing IFDB pages, and has a
"Click to Play" button that lets you download and run any game you're
looking at through its IFDB browser.

<p>The Meta Installer architecture is designed to allow the client
component to be implemented on any OS, and supports a variety of
configurations, including browser plug-ins (such as we use on Windows)
and custom IFDB browser apps (such as Zoom on Mac).  This document
describes the generic architecture of the client piece, plus its
specific implementation on Windows.  This is all meant as an
implementation guide for platform developers who want to create
similar functionality for other operating systems, or who want to
integrate similar functionality into their custom apps.


<h2>Call for Platform Experts</h2>

<p>Are you an expert in one of the popular IF game engines?  Are you
an expert on an operating system?  If so, we'd like to ask you to
consider becoming an official IFDB Download Adviser expert.

<p>A key element of the Download Adviser design is that the work of
entering and maintaining platform-specific instructions can be divided
up among a group of experts in the different operating systems and
game engine format experts.  This gives the people closest to the
various systems direct access to update their sections, so they don't
have to wait for a central administrator to notice changes or enter
updates.

<p>We currently have participants covering the major operating systems
and game engine formats, but some of the smaller systems are not yet
covered.  If you're interested in taking ownership for the IFDB
Download Adviser for a game engine and/or operating system, please
contact me.

<p>Here's what you'd be asked to do as an engine or OS Download
Adviser expert:

<ul>

   <li>Create a user account on <a href="http://ifdb.tads.org">IFDB</a>.
   (Use an email address that's recognizably you - we want users to be
   able to trust that the download instructions won't be hijacked to
   point to malware, so we want to keep write access limited to
   trustworthy individuals.)

   <li>Let ifdbadmin@ifdb.org know about your new account, and the
   OS/format combinations you want to manage, so that I
   can give you write access to the relevant entries.

   <li>Go to the <a href="http://ifdb.tads.org/fileformat">File Format list</a>
   and/or the <a href="http://ifdb.tads.org/opsys">OS list</a>, depending
   on your area of expertise.  Click through to the formats or OSes of
   interest.

   <li>For each combination of OS and Format within your jurisdiction,
   add a Download Adviser entry:

   <ul>
      <li>Write human-readable instructions to download and install
      the interpreter.

      <li>Write human-readable instructions to run the player.

      <li>If the OS has a Meta Installer, write the Meta Installer
      XML commands for downloading and installing the interpreter.
      Currently, only Windows has a Meta Installer, but more of these
      could be written in the future.  (For this, some reading will
      be required.  The summary for the Windows Meta Installer
      is <a href="#win_xml_summary">here</a>; the
      full details are  <a href="#win_metainstall_format">here</a>.)
   </ul>

   <li>For Windows interpreter developers only: Assuming ratification
   of my <a href="#new_terp_reg_keys">registry keys proposal</a>, we will
   all need to implement it.  This should be very easy - we just need
   to write a new key to the registry during installation, and optionally
   update it whenever the Interpreter is executed to ensure that it
   remains current even if the user manually moves around the
   Interpreter's directory tree.

   <li>On an ongoing basis, update the entries you created above whenever
   necessary (because of a new Interpreter release, for example).
   Ideally, Interpreter developers will put this step into their
   release processes.

</ul>



<h2>Background</h2>

<p>I've been working on a new IF catalog and recommendation site that
I'm calling <a href="http://ifdb.tads.org/">IFDB</a> (for Interactive
Fiction DataBase).  The main thrust of the site is to try some new
approaches to community recommendations for IF, but I felt it was
important for the sake of user experience to provide integrated
catalog features as well.  Part of that integration is, of course,
direct download links to the cataloged games.

<p>A perennial problem for IF newbies is figuring out how to play a
particular IF game once they've found it and downloaded it.  The whole
idea that you'd need separate "interpreter" software to play a game is
rather surprising to the uninitiated - it's just not something you run
into with other computer game formats.

<p>It's not hard for new players to understand the idea once someone
explains it to them - everyone's accustomed to the analogous
requirements for playing MP3 tracks or watching DVDs.  But even once
you understand the idea in principle, there are still all the
practical details: knowing which interpreter you need, finding it,
installing it, and keeping it up to date.

<p>Those of us who've been playing or writing IF for a long time take
a lot of background knowledge for granted - we know who Hugo is, what
a "Frotz" is, how Inform, Z Machine, and Frotz are related, how the
directories in the IF Archive are laid out - heck, we know there's
such a thing as the IF Archive in the first place.

<p>If you step back and think about it, there are an awful lot of
little details you have to correlate to get this stuff working.  I've
actually been stepping back and thinking about it, because I've been
creating sample "recipes" for setting up to run particular IF formats
on particular operating systems.  What I've found is that all the
grousing you hear from newbies on the newsgroups is a lot more
justified than I used to think.  The main problems are

<ul>
   <li>It's hard to know exactly what you're looking for, because
   the <i>format</i> and the <i>interpreter</i> for the format
   are separate things.
   <li>Instructional resources are scattered far and wide, among
   various FAQs, system sites, and "about IF" sites.
   <li>A lot of the FAQs and "about IF" sites are out of date.  The
   system sites tend to be current, since they're maintained by
   the system developers, but they're not always good sources of
   information on <i>playing</i> the games their systems produce,
   because their interpreter ports are often maintained by other people.
</ul>

<p>I've been working on an approach that I think will solve these
problems and make it easy for newbies to get accurate, up-to-date
information about a particular game they want to play.

<p>My approach is to create a matrix of recipes - one for each
combination of format and operating system - and integrate this into
the IFDB catalog.  This might sound like just another FAQ mechanism,
but I think it's a little different.  Here's how it solves the
problems identified above:

<ul>
   <li>It solves the problem of having to figure out which interpreter
   goes with which format, or even of figuring out what format a
   game uses in the first place.  The user just picks a game:
   IFDB knows the format, because each catalog listing is tagged
   with that information.

   <li>It solves the problem of finding the appropriate instructions,
   because they're integrated directly into the game's listing on
   IFDB.  When you find a game you want to play, the instructions are
   right there with it.  IFDB can cross-reference the format (which
   it knows from the game listing) with the user's OS, and retrieve
   the specific set of instructions at that spot in the matrix.

   <li>It unrolls the conditional branches that you find in the typical
   instruction sets available now, so that users don't have to wade
   through the branches themselves looking for the relevant sections.

   <li>It <i>could</i> solve the currency problem.  Granted, this one
   isn't a lock; ongoing maintenance will always be required, and
   matrix entries will certainly slip out of date if they're neglected.
   Nonetheless, I think this scheme gives us our best shot at maintaining
   an authoritative, current, centralized set of instructions.  The reason
   all of the other FAQs and "about" sites are out of date is that they
   all rely on their respective individual maintainers.  IF is a hobbyist
   pursuit; all of
   us come and go according to our real lives.  Anything that depends
   on one person for maintenance will have long periods of inattention.
   So the point here is that IFDB's recipe system <b>must not</b>
   be bottlenecked on me - maintenance responsibilities will have to be
   distributed among a number of people if it's going to stay current.
   My original idea was that the recipes would be open to public
   editing, as a typical Wiki/Web-2.0-style free-for-all.  But I decided
   that was a bad idea; the recipe system will be predominantly pointers
   to executable software downloads, and I think for the sake of security
   and user trust, the source of the recipes needs to be controlled.
   So, instead of wide-open public editing, the plan is that certain
   trusted users will have access to
   edit particular OS-related entries and/or particular format-related
   entries.  Our best hope for keeping things current is to directly
   enlist the developers of the various systems and interpreters.
   Ideally, each system developer would make it part of their release
   process to update the IFDB recipe(s) for their system - that would
   almost guarantee that the recipes are kept up to date with releases.

</ul>

<p>IFDB actually has <i>two</i> mechanisms for helping newbies with
installation.  The first is the "Download Adviser," which works
basically as described above: when the user picks a game, IFDB
cross-references the format (as specified in the game listing) with
the user's operating system (obtained from the browser ID string, or
selected by the user from a drop-down list), looks up that combination
in the matrix, and displays the human-readable instructions stored
there.  The goal is to provide precise and complete instructions, with
direct hyperlinks to any files that need to be downloaded, and
<i>without</i> any conditionals ("if you're using <i>this</i> version
of Windows...") or buck-passing to FAQs or other third-party sites.
The instructions should be completely linear and self-contained, so
that a user can just run down the list and have the game actually up
and running when done.

<p>The second mechanism is the IFDB Meta Installer.  This is
essentially an automated version of the Download Adviser.  Like the
DLA, the Meta Installer uses a server-side program that correlates a
game's file format information with the user's operating system to
produce system-specific download instructions.  Unlike the DLA,
however, these download instructions are machine-readable rather than
human-readable, because they're designed for consumption by a separate
client-side portion of the Meta Installer.  The client-side piece
executes the instructions to actually perform the installation
directly, so that the user doesn't have to do any manual installation
work.


<h2>Download Adviser Algorithm</h2>

<p>Note: To see an example of the DLA in action, go to <a
href="http://ifdb.tads.org"> ifdb.tads.org</a>, search for Deep Space
Drifter (or any other TADS 2 game), click "Show Me How" in the
Download box, and make sure that you have a Windows OS version
selected in the OS list.  I haven't loaded instructions for most of
the other format/OS combinations yet, but this will give you an idea
of how the instructions are displayed.

<p>The principal behind the DLA is straightforward.  It correlates
several pieces of information in a database to find the correct set of
instructions.  We start out with the following information:

<ul>

   <li>The user views a game in the IFDB catalog, and decides she wants to
give it a try.  From the game's main page, she clicks a "Download
Help" button to ask for download-and-install instructions.
   
   <li>The user chooses a target operating system.  (This step is
bypassed if (a) the user has already chosen an OS for another game
during this same session, (b) has a stored preference setting for a
preferred OS, or (c) IFDB can guess the OS based on the browser's ID
string.  Even if we bypass the manual OS selection step, the user can
still override the OS selection later using a drop-down list on the
instructions page.)

   <li>Each game in the database has an associated list of download
links; the links can include various format incarnations of the
playable game (e.g., TADS .gam file, Windows .EXE installer, and
Macintosh standalone app), as well as ancillary supporting materials
(user's manuals, "feelies," hints, maps, walkthroughs, source code,
etc).

   <li>Each download link is marked with its <b>file type</b>.  This
is a format type in the sense of a MIME type or a Windows filename
extension mapping, but we don't use those particular mechanisms.
Instead, IFDB keeps its own separate metadata field for each file
indicating its type.  The list of types isn't as exhaustive as the
MIME-type list or a typical Windows HKEY_CLASSES_ROOT list, but it
does include all of the actively used Story File formats, plus native
Executables and Installers, plus a number of other common formats used
frequently in the IF Archive (plain text, HTML, PDF, various image
types, executables, installers...).  The current list is
<a href="http://ifdb.tads.org/fileformat">here</a>.

   <li>For the Executable and Installer formats, the file information
is further qualified by the operating system ID <a
name="returnnote1"></a>[<a href="#footnote1">1</a>].  Anything that's
not an executable is a document, which makes it usable on any platform
with a viewer/editor/player/interpreter application for that file type
<a name="returnnote2"></a>[<a href="#footnote2">2</a>].  This doesn't
necessarily mean that a viewer exists for every platform, but in
principal a viewer <i>could</i> be written for virtually any document
format on virtually any platform; so from this perspective, document
files are inherently portable and thus don't need to be qualified by
operating system.

   <li>Each format has a <b>class</b>.  The classes are:
   <p><ul class=tight>
      <li>Executable
      <li>Story File
      <li>Compressed archive format
      <li>Unspecified/other
   </ul>

   <li>A table of "Instructions" records stores the instructions for a
given file format/OS version combination.  Each of these records
includes (1) instructions to download and install a
player/viewer/editor application that handles the given file format on
the given OS; and (2) instructions to invoke that application, once
installed, to open a given file.

</ul>

<p>The DLA's goal is to produce step-by-step instructions that start
with a "bare" machine of the user's selected OS (i.e., with only the
normal set of factory pre-installed software that we can count on
being available on any machine running this OS), and finish with the
selected game up and running.  The algorithm takes the information
above and uses it as follows to produce the instruction list:

<ul>

   <li>First, we have to find a compatible version of the game.  We
   run through the link list looking for files with format class
   Story File; or with format class Executable <i>and</i> file
   type Story Program or Story Installer <i>and</i> the same operating
   system as the target OS <i>and</i> an equal or later OS version.

   <li>According to the user's preference, we select either the
   Story File that we found or the executable (the Story Installer
   if we found it, the Story Program if not).  If there's nothing
   matching the user's preference for executables vs. non-executables,
   we report this and terminate.

   <li>If the file we selected is marked as compressed, we generate
the instructions to decompress it.  This is done using the same
procedure we use for downloading and installing an interpreter, which
we'll come to in a moment, but we use the Instructions records
associated with the compression format rather than for the story file
format.

   <li>If the file we selected is compressed, we note the "primary"
file from the archive, as specified in the link record - this should
be the actual name of the story file or executable within the archive.
In subsequent instructions that refer to the file, we use the name of
this primary file rather than the name of the compressed file, since
the compressed file is just a wrapper, and the real file we want to
work with is the primary file inside.

   <li>What we do next depends on the type of file we selected above:

   <ul>

      <li>If we found an executable, the instructions are simple:
      just download and run this file.

      <li>If we found a story file, we first generate an instruction
step to download this file.  We then need to explain how to find and
install interpreter application.  We look up the Instructions records
for the combination of target OS and the story file's format (TADS 2,
Z-Machine, etc).  We look up the records for <i>all</i> versions of
the target OS, then we find the one with the highest OS version less
than or equal to the target OS version <a name="returnnote3"></a>[<a
href="#footnote3">3</a>].  We display the DOWNLOAD AND INSTALL
item from this record, then display the RUN item.  We count on this
record having been prepared by an expert for the file format and OS,
so this should give the precise instructions that the user needs.  If
we can't find any record for the format/OS combination, we look for an
entry for the format in the special pseudo-OS "All OS Defaults"; this
entry allows a format expert to create a default catch-all entry,
which could (for example) refer the user to the system developer's
site.  If we find this catch-all entry, we display it; otherwise, we
tell the user that no instructions are available for their OS and
terminate.

   </ul>

</ul>

<h3>Handling intepreter version incompatibilities</h3>

<p>The basic versioning assumption we make for a game format is that
<b>a newer interpreter can play an older game</b>.  That is, if a game
is compatible with version N of the interpreter, we assume that it's
also compatible with interpreter version N+1, N+2, etc.

<p>Whenever this assumption holds, the DLA only needs to know about the
latest version of the format's interpreter for a given OS.  As long as
a user has the latest interpreter, they can be assured that they can
play any game created for the format.

<p>However, this assumption is not always true.  Some formats have
been known to break compatibility at certain version updates.  When
compatibility is broken, the solution for the DLA is to treat the
two versions as <b>separate formats</b>.

<p>For example, TADS 2 and TADS 3 are separate formats in the DLA
because they require separate interpreters.  (On most platforms, this
detail is hidden from users because the TADS interpreters are bundled
with <b>both</b> VM versions, and can automatically detect which one
to run for a given game.  But this isn't necessarily true everywhere,
so it's important to treat the two formats as incompatible in the DLA
records to allow specifying different interpreters for operating
systems that require them.)

<h2>Sample DLA Entry</h2>

<p>Here's the DLA entry for TADS 2 on Windows:

<p><b>Instructions for downloading and installing the
Interpreter/Player/Viewer application for this format:</b><br>
<blockquote>
   <pre>
If you don't already have a TADS Interpreter on your system, install
it as follows:

&lt;ul&gt;
&lt;li&gt;&lt;run&gt;http://www.ifarchive.org/if-archive/programming/tads2/executables/htads_playkit_HT12.exe&lt;/run&gt;

&lt;li&gt;Follow the Setup program's prompts to install the Interpreter.
&lt;/ul&gt;
   </pre>
</blockquote>

<p><b>Instructions for running the Interpreter/Player/Viewer application
   to run/play/view a local file called {fname}:</b><br>
<blockquote>
   <pre>

To run the game:
&lt;ul&gt;
&lt;li&gt;From the Start menu, select TADS &gt; HTML TADS Interpreter
&lt;li&gt;In the Interpreter window, open the &lt;b&gt;File&lt;/b&gt; menu
and select &lt;b&gt;Open New Game&lt;/b&gt;.  This will display a file
selector dialog - select {fname} to start the game.
&lt;/ul&gt;
   </pre>
</blockquote>

<p>To see how these entries look once formatted, go to
<a href="http://ifdb.tads.org">IFDB</a>, search for Deep Space
Drifter, click through to the game page, click the
"Show Me How" button near the top right; if necessary,
select a Windows version from the OS list and click Go.


<p><hr><font color="#008000">If your main interest is the human-readable
Download Adviser instructions, you can stop here - the rest of this
document is about the Meta Installer design.</font><hr>

<h2>Meta Installer Operation</h2>

<p>The Meta Installer works on the same principle as the Download
Adviser to generate the install plan, and uses the same algorithm that
the DLA uses to generate instructions.  However, rather than
assembling the human-readable form of the instructions, the Meta
Installer version of the algorithm assembles a machine-readable
installation plan.  The source of the pieces of the machine-readable
plan is right alongside the human-readable instructions - the Meta
Install plan fragments are stored in the Instructions table in columns
parallel to the human-readable instruction fragments.

<p>Every operating system has different installer needs, so there's
no point in designing a universal specification for the detailed
installation procedure.  Instead, we define only the overall flow
of information, and we leave it up to the individual plug-ins to
define the details of their installation instructions.

<p>Note that we refer to a "plug-in" as the client-side component that
carries out the installation tasks.  We use this term generically;
this piece will have no user interface presence on the game listing
page itself, so it can be implemented using almost any sort of browser
extensibility mechanism - or even by creating a non-browser client.
Some examples:

<ul>

   <li>An ActiveX control for IE
   <li>A Netscape plug-in for Firefox and other browsers
   <li>An IE "browser helper object"
   <li>A non-browser container application that embeds an HTML viewer
   for displaying pages

</ul>

<p>In order to allow maximum flexibility for the client piece, we've
tried to keep the interaction between the client, server, and game
listing page as simple as possible.  The plug-in (or whatever it is)
has no user interface presence on the game listing page - the only
thing it has to do is provide a simple scripting interface, which the
"Play Now" button invokes via Javascript when the user clicks on the
button.  In fact, scripting isn't even necessarily required: the
invocation could alternatively be accomplished by hyperlinking the
"Play Now" button to a special HREF (using a custom scheme, for
example), in which case the client software would simply need a way to
intercept outgoing HREF requests, and would trigger the installer when
the special HREF appears.  Remember, we control the server: we can
work with each plug-in developer to create whatever custom HTML
plumbing you need to turn a user click on the "Play Now" button into a
plug-in invocation.


<p>The overall control flow for the plug-in is as follows:

<ul>

   <li>The IFDB page for a given game has a Download box that lists the
   URLs of the game and its components that are available for download.
   As part of this box, if the user has a plug-in installed, the
   server will insert a "Play Now" button suitable for the plug-in
   installed.

   <li>To detect what code to generate, the IFDB server looks at the
HTTP user agent ID string passed by the client's browser.  This string
contains information on the browser and operating system being used.
Each plug-in developer will work with the IFDB developers to design
the appropriate detection code for the plug-in's target browser or
browsers, and to design the appropriate form of the "Play Now" button
<a name="returnnote4"></a>[<a href="#footnote4">4</a>].  Note
that we could also use cookies to control plug-in detection, if that's
more suitable for a particular client.

   <li>If the user doesn't have a plug-in installed, or doesn't have
   a browser for which a plug-in exists, we omit any sort of "Play Now"
   button and just present the normal Download box.

   <li>If the user wants to use the Meta Installer to install the
   game, the user presses the generated Play Now button.  This uses
   browser-specific techniques - usually scripting - invoke the
   plug-in's "install" entrypoint.  Either as part of calling this entrypoint,
   or as part of instantiating the plug-in, the page must pass the TUID
   of the game being viewed to the plug-in; the details of how this is
   done can vary arbitrarily by browser, since we can write custom
   code on the server to generate whatever format is needed for
   each plug-in <a name="returnnote5"></a>[<a href="#footnote5">5</a>].

   <li>The plug-in, on having its "install" entrypoint invoked,
   sends an HTTP GET to the following URL (this is a fixed URL
   that can simply be hard-coded into the plug-in):
   <p>
   <pre>  http://ifdb.tads.org/dladviser?id=<i>TUID</i>&amp;os=<i>OSID</i>&amp;xml</pre>

   <p>where <i>TUID</i> is the game identifier passed in from the hosting
   web page, and <i>OSID</i> is an identification code that specifies
   the client machine's operating system.  The <i>OSID</i> value is taken
   from a published list of IDs stored on the IFDB server - plug-in
   developers should simply obtain the necessary ID codes from the IFDB
   developers.  The plug-in should use local OS APIs to determine which
   version of the OS the user is running, if necessary, so that the
   most relevant version of the instructions can be generated.

   <li>IFDB replies with an XML document (Content-Type "text/xml"), as
   described further below.

   <li>The installer parses the XML, determines whether the request was
   successful or not, and proceeds with the installation according to the
   instructions if it was successful.  What happens from here varies by
   system, but in general the instructions will involve (a) checking
   for an existing installation of a piece of software, including a
   version number check; (b) downloading from a URL passed in via
   the XML; (c) unpacking files from a compressed format
   such as ZIP or .tar.gz; and (d) "installing" the downloaded software
   according to local conventions, which might mean moving it to a
   particular directory, executing the downloaded software as a
   subprocess, invoking a standard system installer program on the
   downloaded file, etc.

   <li>Remember, the contents of the instructions and the capabilities
   of the plug-in are designed in lock-step.  The instructions aren't
   some kind of generic, universal install spec - they're custom-built for
   <i>your</i> plug-in.  (The only thing that's common to all platforms
   is the XML packaging of the instructions.  The actual contents are
   customized per-platform.)  In other words, the plug-in developer writes
   the specification for what can go in the download instructions.
   The OS/format expert who writes the automatic download instructions
   has to write them according to your spec.  A Macintosh plug-in will
   never receive instructions designed for the Windows IE plug-in, so
   a Mac plug-in developer doesn't have to worry about what the Windows
   IE plug-in developer is doing.

</ul>

<p>IFDB uses a limited subset of XML functionality in the returned
XML.  This is intentional, so that the client can use a very
lightweight parser implementation.  The XML returned will be limited
as follows:

<ul>

   <li>No tag attributes are used, <i>except</i> for the "version"
   attribute in the initial &lt;?xml?&gt; processing directive
   and the namespace identifier in the root &lt;autoinstall&gt;
   tag.

   <li>Namespace syntax will not be used <i>except</i> for the
   default namespace identifier in the root &lt;autoinstall&gt; tag.
   No namespace prefixes will be used on tag names, and no other
   "xmlns" attributes will be used.

   <li>The content of a container tag will be <i>either</i>
   text <i>or</i> one or more sub-nodes.  There will be no mixing
   of tags within text.

   <li>Within text, the only "&amp;" entities used will be
   &amp;amp;, &amp;lt;, &amp;gt;, &amp;quot; (double quote), and
   &amp;#039; (single quote).

</ul>

<p>Note that these restrictions apply to the generic XML that IFDB
generates.  The additional XML that's specific to each operating
system can ignore these restrictions if desired.  Since the
OS-specific part is up to the plug-in developers for each OS to
define, this means that you can decide when designing your plug-in
whether or not you want any additional XML functionality in your
OS-specific part, and weight that against the cost of parsing it.

<p>The XML reply has this overall structure:

<pre>
  &lt;?xml version="1.0"?&gt;
  &lt;autoinstall xmlns="http://ifdb.org/autoinstall" version="1"&gt;
     <i>contents</i>
  &lt;/autoinstall&gt;
</pre>

<p>Note: the result XML won't necessarily be formatted as shown.  In
particular, we show the results with a nice newline and indenting
structure for readability, but the placement of newlines and
start-of-line indenting might vary in practice.  Clients must parse
the data according to the normal XML rules for treatment of whitespace
- <i>don't</i> count on indenting or newlines in actual results as a
guide to the tag nesting structure.

<p>On any error, the <i>contents</i> will have this structure:

<pre>
  &lt;error&gt;
    &lt;id&gt;<i>error code</i>&lt;/id&gt;
    &lt;message&gt;<i>human-readable error message</i>&lt;/message&gt;
  &lt;/error&gt;
</pre>

<p>The possible codes are:

<ul>
   <li>MISSING OS: Invalid network request - the OS parameter is missing.
   <li>INVALID OS: The specified operating system is not valid.
   <li>NO INSTRUCTIONS: Automatic download information is not currently
     available for this game on your operating system.  You might still
     be able to download the game manually - check availability
     in the Download box on the game's main page.
   <li>GAME NOT FOUND: No entry was found for the specified game.
</ul>

<p>On success, the <i>contents</i> will be as follows:

<p>
<pre>
  &lt;clientversions&gt;
     <i>version info</i>
  &lt;/clientversions&gt;
  &lt;ifarchivemirror&gt;<i>mirror URL</i>&lt;/ifarchivemirror&gt;
  &lt;tuid&gt;<i>tuid</i>&lt;/tuid&gt;
  &lt;ifids&gt;
    &lt;ifid&gt;<i>ifid1</i>&lt;/ifid&gt;
    &lt;ifid&gt;<i>ifid2</i>&lt;/ifid&gt;
    ...
  &lt;/ifids&gt;
  &lt;version&gt;<i>version</i>&lt;/version&gt;
  &lt;title&gt;<i>game title</i>&lt;/title&gt;
  &lt;author&gt;<i>game author</i>&lt;/author&gt;
  &lt;download&gt;
    &lt;game&gt;
      &lt;href&gt;<i>game download URL</i>&lt;/href&gt;
      &lt;compression&gt;
        &lt;id&gt;<i>format ID</i>&lt;/id&gt;
        &lt;name&gt;<i>format name</i>&lt;/name&gt;
        &lt;primaryfile&gt;<i>filename</i>&lt;/primaryfile&gt;
      &lt;/compression&gt;
      &lt;type&gt;<i>file type</i>&lt;/type&gt;
      &lt;format&gt;
        &lt;id&gt;<i>format ID</i>&lt;/id&gt;
        &lt;name&gt;<i>descriptive name</i>&lt;/name&gt;
        &lt;interpreter&gt;
          <i>items</i>
        &lt;/interpreter&gt;
        &lt;interpreter&gt;
          <i>items 2</i>
        &lt;/interpreter&gt;
        ...
      &lt;/format&gt;
    &lt;/game&gt;
    &lt;extra&gt;
      &lt;href&gt;<i>extra file URL</i>&lt;/href&gt;
      &lt;title&gt;<i>extra file title</i>&lt;/title&gt;
      &lt;desc&gt;<i>extra file description</i>&lt;/desc&gt;
      &lt;formatid&gt;format ID&lt;/formatid&gt;
      &lt;compression&gt;
        &lt;id&gt;<i>format ID</i>&lt;/id&gt;
        &lt;primaryfile&gt;<i>filename</i>&lt;/primaryfile&gt;
      &lt;/compression&gt;
    &lt;/extra&gt;
    ... <i>more extras</i> ...
  &lt;/download&gt;
</pre>

<p>The &lt;clientversions&gt; element contains information about
the current versions of the plug-in software.  This is to facilitate
automatic updates of the client piece, and is discussed in detail
<a href="#auto-update">below</a>.

<p>The &lt;ifarchivemirror&gt; tag gives the base URL to the user's
preferred IF Archive mirror site.  This will be supplied only if the
user is logged in.  The server will <i>already</i> have remapped any
IF Archive URLs it actually knows about within the XML; so, for
example, the download/game/href and download/extras/extra/href values
will already be mapped to the correct mirror URL when you receive the
XML.  However, the server <i>won't</i> map URLs in the
&lt;interpreter&gt; sections, since the contents of those sections are
opaque to the server - the plug-in is the only piece that can
interpret those sections, so it's where any URL remapping must take
place.  The mirror URL is supplied in the XML information for this
reason, and also so the plug-in can remap any IF Archive URLs encoded
directly into the plug-in itself (for example, a plug-in might be
designed to check for updates to its own code by looking at a
particular IF Archive URL).  To use the mirror URL information, simply
look for the prefix "http://www.ifarchive.org/if-archive/" in any URL
you'll be using for a download, and substitute the contents of the
&lt;ifarchivemirror&gt; tag for that prefix when you find it.

<p>The name and title can be used to ask the user for permission and
confirmation, to make sure the user intended to install this
particular game.

<p>The TUID, IFID, and version number are provided mostly in case the
Meta Installer wants to keep track of which games have previously been
downloaded in its own internal (client-side) database.  The TUID is a
stable, unique identifier for the game <a name="returnnote6"></a>[<a
href="#footnote6">6</a>], so it can be used to determine if the same
game is already installed - if it is, the plug-in can simply run the
existing copy rather than downloading it again.  The version is
provided so that the plug-in can notify the user that an updated
version is available.  (Note that the formatting of the version number
is arbitrary and might not be suitable for any sort of general-purpose
greater-than/less-than comparison algorithm - it could be something
like "7", "1.2.29", or even "Third Edition"; it's probably best to
assume that the server version is newer if it doesn't match a previous
copy's version string byte-for-byte.)

<p>If you do want to cross-reference new requests with past downloads,
it's up to you to maintain a record of the past downloads, and to make
sure that the user hasn't deleted the game, etc.  Maintaining a
database of past downloads is nice because it turns IFDB into a sort
of universal IF jukebox; from the user's perspective, it doesn't
matter whether or not a game has been downloaded before, since
clicking "Play It Now" will have the same effect either way, modulo
the download time of new downloads.  (In the future, we could even
think about integrating local saved games with the IFDB listing pages,
with some help from the plug-in.)

<p>The IFIDs are provided for the same reason as the TUID.  The client
component can use the IFIDs to identify the game instead of the TUID,
if desired.  IFIDs are part of the <a
href="http://babel.ifarchive.org">Treaty of Babel</a>, so they're more
likely to be interoperable; this might be important to some client
implementations.  (But see note [<a href="#footnote6">6</a>] on why
the TUID might be easier to use.)

<p>The &lt;download&gt; section gives the download information for
one game program file, plus any number of extra accompanying files.

<p>The game download information is given as a URL plus file type
information, plus possible compression information.  The URL is a link
to the game's story file, or to a compressed archive containing the
story file.  This is a direct link to the file resource itself, not to
an HTML page containing a link to the file resource, so downloading
the game is just a matter of doing an HTTP GET (or equivalent for
other protocols, if the scheme in the URL is something other than
"http:") on this URL and saving the returned content to the local hard
disk.

<p>If the compression information is present, it gives the ID and name
of the compression format used for the file.  The ID comes from a
published list on the IFDB site, and includes entries for ZIP,
.tar.gz, .tar.Z, etc. [<a name="returnnote9"</a><a
href="#footnote9">9</a>]  These ID values are permanent public ID
values that will not change over time (although new ones might be
added).  The compression format name is a human-readable
name for the format; this <i>isn't</i> guaranteed to be stable
over time for a given format, and could even be affected by things
like the user's language preferences.  The compression format name
is supplied mostly for UI purposes; for example, if the client
software doesn't know how to handle a format, it can display the
format name in an error message.

<p>The "primaryfile" part of the compression entry tells you the name
of the game itself within the compressed archive - this is the name of
the file that you'll send to the interpreter to run the game after
you've extracted the contents of the archive.  Note that this
information isn't guaranteed to be provided, since it depends on
someone having entered it for the download link in the game's listing;
if it's not present, the Meta Installer might be able to guess anyway
(by scanning the unpacked files and looking for one with the right
filename extension, file signature, OS-specific type metadata, etc) -
to the extent this is possible for a given format on a given OS, it
will have to be encoded in the system-specific &lt;interpreter&gt;
section.

<p>The &lt;type&gt; gives the type of the file.  This is orthogonal
to the format: it tells you what you do with the file rather than how.
There are three type codes:

<ul>
   <li>storyfile: the downloaded file is an interpreter-based story file.
   The &lt;interpreter&gt; section will always be provided in this case
   to tell you how to install the required interpreter.

   <li>storyprogram: the downloaded file is the game in native
   executable format - that is, to run the game, you simply run this
   application.

   <li>installer: the downloaded file is an installer that you need
   to run to set up the game. The installer should execute this program;
   the expectation is that the program will install the actual story
   program and terminate.
   [<a name="returnnote10"></a><a href="#footnote10">10</a>]
</ul>

<p>Note that the IFDB server prioritizes file matches in the order
shown - so if a story file version is available, that will be the file
specified in the XML, even if the other types are also available.
Story files are almost always smaller and safer (in terms of malware)
than executables, so IFDB returns them in preference to executable
formats whenever possible.

<p>The &lt;format&gt; section gives information on the file's format:
its human-readable name ("TADS 2", "Z-Machine", etc), and its ID code.
The ID code is the published identifier that IFDB uses to identify the
format.  The Meta Installer might want to store this information its
internal database of installed formats, since it might be useful to
use in future transactions with the IFDB server.  For example, the
Meta Installer could pass this to IFDB to request an update for the
format separately from any particular game.

<p>The special format "executable" indicates that the downloaded file
(or the primary file, if it's a compressed archive) is a native
executable application for your operating system.  When this type of
file is downloaded, there will be no &lt;interpreter&gt; section, for
obvious reasons; there will also be no descriptive name (the
&lt;name&gt; section) for the format.

<p>Each &lt;interpreter&gt; section provides information on how to
download and install an interpreter for this game's format.  The
contents of this section are entirely up to the plug-in developers for
each OS to design.  The IFDB instructions matrix is keyed on OS - it
doesn't have separate slots for multiple plug-ins on one OS - so all
of the plug-ins for a given OS will have to share the same instruction
format.  However, to the extent an OS has multiple plug-ins with
different needs, the plug-ins can still easily differentiate their
instructions simply by splitting them up into separate XML
subsections.  The OS/format expert would simply be required to enter
the combination of &lt;interpreter&gt; sub-items to cover all of the
different plug-ins for that OS.

<p>The &lt;interpreter&gt; section can appear more than once, because
some formats have multiple interpreters available for the same
systems.  For example, there are several Z-Machine interpreters for
Windows.  By listing all available interpreters, we allow the Meta
Installer to detect if the user has <i>any</i> interpreter compatible
with the format.  Some users prefer one interpreter over another, so
we don't want to bother a user who's already installed one of the
alternative terps.  If none of the alternatives are found on the
user's system, it's up to each OS plug-in to determine how to proceed;
we recommend treating the first &lt;interpreter&gt; section as the
"preferred" interpreter, and automatically installing that one.  (A
plug-in could alternatively offer the user the whole list and let the
user decide, but this seems at odds with one of the key goals of the
project, namely making the game configuration process as seamless
and automatic as possible.)

<p>In general IFDB will generate the &lt;interpreter&gt; sections as
follows:

<ul>
   <li>IFDB will find the instructions record for the OS/format
   combination, the same way it does to generate DLA instructions

   <li>This instruction record will have a field for the Meta Installer
   data.  This field, if set, will contain an XML fragment.  This fragment
   will have been entered by the OS/format expert for your system,
   <i>according to your specifications</i>.

   <li>IFDB will copy this fragment into the &lt;interpreter&gt;
   list.
</ul>

<p>The &lt;extra&gt; file sections give the download information for
any supplemental files (documentation, feelies, walkthroughs, source
code, etc) associated with the game.  The title and description
information are as entered in the IFDB listing for the file.  The
compression information works the same way it does for the game file;
for extras, the "primary file" is usually irrelevant, but the server
includes the information if it's in the database, in case it's ever of
interest.  For an extra file, the format information is provided only
as a format ID (which comes from the same published list as the format
ID for a game file).  For extra files, we <i>don't</i> provide any
information on a viewer application, since it's well beyond the scope
of this project to provide automatic installation procedures for
arbitrary document format viewers.


<h2><a name="auto-update"></a>Versioning and automatic update support</h2>

<p>The client plug-ins will inevitably be updated over time, to add
features and fix bugs.  Some client implementations might want to
provide integrated automatic updates.

<p>This is particularly important for clients that are implemented as
browser plug-ins of one kind or another, since these types of programs
tend to be fairly invisible to the end user - they usually just sort
of blend into the browser, and don't tend to have a separate user
interface presence of their own.  This makes it important for the
client to be as self-maintaining as possible.

<p>To facilitate automatic updates, the XML sent from the server
includes the &lt;clientversions&gt; section.  This section contains
elements that give the version information for the current client
programs available for download from the server.  This section's
direct children are sub-tags for the individual client implementations.
Currently, the contents are as follows:

<p>
<pre>
&lt;windows-plugin&gt;
  <i>version information for the Windows browser plug-ins</i>
&lt;/windows-plugin&gt;
</pre>

<p>The contents of a given section are up to the corresponding plug-in
developer to define.  In general, the plug-in developer will send the
IFDB administrators the exact contents of their relevant section with
each release update, and the IFDB administrators will copy this text
verbatim into the main version file on the server; the server will
in turn copy this text verbatim into the XML sent to the client.

<p>As new plug-ins are developed, we will add new tags to this
section corresponding to the new plug-ins.

<p>The IFDB administrators will be responsible for maintaining the
IFDB server with the current client software download sets and the
corresponding version information.  Plug-in developers will send each
new release's download set to the IFDB administrators along with
current version numbers; the administrators will copy the release set
to the server and update the version file.  It's up to each plug-in
developer to determine the format of an update set; on Windows, for
example, this is simply a ZIP file containing the full current
client binary release.



<h2><a name="win_metainstall_format"></a>The &lt;interpreter&gt;
section for Windows</h2>

<p>Now we come to the detail specific to the Windows plug-ins.  This
section applies only to Windows; other systems that have plug-ins will
presumably need similar functionality, but how they accomplish it will
depend on the local OS conventions and facilities; and, of course,
systems that don't have plug-ins won't need this information at all.


<h3>Basic installation process</h3>

<p>On Windows, there are several ways that freeware-type applications
are commonly distributed: 

<ul>

   <li>"EXE": As a simple executable program file.  The user downloads
the file and saves it in an arbitrary folder.  To run the program, the
user simply launches the downloaded EXE file.  This type of installation
is rare, since most applications need some support files beyond the
executable.

   <li>"ZIP": As a compressed archive (almost always ZIP; in rare
cases, .tar.gz or .tar.Z) containing the application's executable and
support files.  The user downloads the archive, unzips it into an
arbitrary folder, and runs the program by launching the .EXE that got
unpacked into the app folder.  The ZIP file can be discarded after
its contents have been unpacked.

   <li>"SETUP.EXE": As a .EXE file containing a SETUP program.  The
user downloads the .EXE and launches it; the .EXE performs the
installation, almost always with some user input through a UI
displayed by the SETUP program itself.  After the SETUP program
finishes, it's no longer needed and can be deleted.

   <li>"SETUP.ZIP": Same as above, but the SETUP program (and possibly
some additional support files) are packaged in a ZIP or other
compressed archive format.  The user downloads the file, unzips it
into a temporary folder, and launches the SETUP.EXE file found among
the unpacked files.  After the SETUP program finishes, the temporary
folder and the SETUP.ZIP file itself can be deleted.

   <li>"SETUP.MSI": Similar to the SETUP.EXE case, but packaged as an
install script for the built-in Windows installer program.  The user
downloads the file and double-clicks it to invoke the Windows
installer on the downloaded file.

</ul>

<p>To encode these possibilities, we need three pieces of information:
the URL of the file to be downloaded; the compression format, if any;
and the installation action.

<p>If a compression format is specified, we'll unpack the downloaded
file into a temporary directory, and execute the remaining steps on
the unpacked contents of the archive; we'll delete the temporary
folder when done.

<p>(On Windows, ZIP is by far the dominant compression format.  Even
so, we'll probably support a couple of other formats in the Meta
Installer for the sake of games, since there are a few games on the
Archive in other formats - particularly .tar.gz and .tar.Z.  Once the
support is there for unpacking games, there's no cost to using it for
unpacking format downloads as well.)

<p>The action code can be one of these:

<ul>

   <li>Save: this applies to the EXE and ZIP formats above.  The Meta
Installer will automatically create a new folder within the
<i>user</i>\Application Data\IFDB folder, giving it an arbitrary name.
It will move the download EXE file or ZIP file contents to this new
folder.

   <li>Run: this applies to all of the remaining formats above.
This action requires an additional parameter giving the name of the
file to launch (this might not be the same as the downloaded file,
since the downloaded file might be a compressed archive containing the
actual file to launch).  The Meta Installer will simply launch the
specified SETUP program, which will be presumed to do the rest of the
installation work.  It will wait for the child SETUP process to
terminate before doing any further work.

</ul>

<p>We'll encode the information for these various installation
procedures as follows:

<p>
<pre>
  &lt;interpreter&gt;
    &lt;href&gt;<i>url</i>&lt;/href&gt;
    &lt;action&gt;<i>action</i>&lt;/action&gt;
    &lt;compression&gt;
      &lt;id&gt;<i>format ID</i>&lt;/id&gt;
      &lt;name&gt;<i>format name</i>&lt;/name&gt;
      &lt;primaryfile&gt;<i>filename</i>&lt;/primaryfile&gt;
    &lt;/compression&gt;
  &lt;/interpreter&gt;
</pre>

<p>The "href" gives the URL of the file to download.  The
Meta Installer starts by downloading this file and saving it in a
temporary directory; the temporary directory and its contents will be
deleted at the end of the installation process.

<p>If the &lt;compression&gt; section is present, it specifies the
compression information: the format ID, human-readable format name,
and the primary file.  The ID is a published identifier that can be
found on the IFDB site; it's guaranteed to be permanent for a given
format.  The compression format name is a human-readable name for the
format, supplied for use in the UI.  The primary file in this case is
the SETUP program to launch, if applicable.  If compression is
specified, the installer extracts the contents of the downloaded file
into another temporary directory before proceeding.

<p>The <i>action</i> is either "save" or "run":

<ul>
   <li>If <i>action</i> is "save", the Meta Installer creates an
   arbitrarily named subfolder in ApplicationData\IFDB and moves the
   files (the downloaded file itself, or its extracted contents if it's
   compressed) there.

   <li>If <i>action</i> is "run", the Meta Installer launches the
   file (the downloaded file itself, or the "primary" file named
   in the &lt;compression&gt; section), either as an application
   or as an MSI file - in either case, it simply goes through the
   standard Windows launch API to get the right process going.
   In any case, the Meta Installer pauses until this launched
   subprocess terminates.
</ul>


<h3><a name="detecting_old_terps"></a>Past installations and updates</h3>

<p>Before we embark on the installation process above, it would be
courteous to make sure that we actually need to do all that work: if
the user already has a current copy of the target program installed,
we should skip the installation process.

<p>Note that we need a <i>current</i> copy of the target program.
This means that if the program has been updated since the user's
version was installed, we should install the new version (or at least
tell the user that there's a new version, and see if they want to
upgrade).  This means that we need to encode version information in
our download instructions.  The version numbers should be encoded in
such a way that two version IDs can be compared to see if one is newer
than the other.  Since almost everyone in the software business uses
version numbers of the form "x.y.z...", we'll adopt this as our
standard format.

<p>There are two cases to consider in detecting past installations:

<ul>
   <li>The past version was originally installed by the Meta Installer
   <li>The past version was originally installed manually by the user
</ul>

<p>The first case - where the software was previously installed by the
Meta Installer itself - is easy to handle.  The Meta Installer can
record each installation it carries out in its own internal database.
When confronted with a new install request, the Meta Installer can
simply look at its database to determine if it previously installed
the same software, and can compare versions to make sure the installed
version is current.

<p>The second case is harder.  The problem is that there's no standard
way on Windows to detect if a particular application has been
installed - we can't rely on folder locations, because most software
lets the user control that; we can't rely on well-known registry keys,
since there's no requirement that applications use registry keys at
all; we can't even rely on file associations, since not all apps use
these, and even apps that do use them often make them optional, and in
any case they're notoriously unreliable because of contention among
unrelated apps for ownership of common extensions.  As I see it, there
are three routes we could go here:

<ol>

   <li>Look for a way to detect a pre-installed version of each of
   the existing IF interpreters, based on their <i>existing</i>
   installation properties - registry keys, file locations, or
   whatever else. [<a name="returnnote7"></a><a href="#footnote7">7</a>]

   <li>Design a <i>new</i> technical standard for detectability
   that interpreters must implement in order to participate in the
   Meta Installer system.

   <li>Ask the user. [<a name="returnnote8"></a><a href="#footnote8">8</a>]

</ol>

<p>Option 1 would clearly ideal, <i>when it can be made to work</i>.  It
doesn't require any new work by interpreter developers (apart from the
work of documenting their particular detection procedures); it'll work
for users who have pre-IFDB interpreter versions installed (the new
scheme won't, because the Meta Installer won't be able to detect older
versions that predate the new detectability mechanism); and it avoids
the question of how we'd get the new standard added to legacy systems
that are no longer maintained.

<p>Unfortunately, Option 1 isn't universally possible, because of the
lack of Windows standards for application identification.

<p>So, we use a combination of (2) and (3).  (2) is reliable; its only
drawback is its lack of backward compatibility.  To address that, (3)
seems easier to implement and more reliable than (1).  While (3) has
the drawback that it creates work for the user, the work is (a)
basically one-time-only (once the user tells us where a particular
interpreter is, we won't have to ask again), and (b) won't happen at
all for newbies who haven't already installed older versions.


<h3><a name="new_terp_reg_keys"></a>IFDB registry keys system</h3>

<p>Option 2 is technically straightforward.  In essence, the goal is
to advertise the presence of an installed service for consumption by
unrelated applications, and the way to do this in Windows is to add
keys to the registry.  So, our technical standard is to define a set
of registry keys that each interpreter sets as part of its
<i>native</i> installation process - that is, it sets these keys for
every install, whether initiated by the IFDB Meta Installer or
manually by the user.

<p>The Meta Installer needs to know (1) whether or not the application
is installed at all, (2) the version, and (3) how to invoke the
interpreter program to run a given game.  It's also useful to
specify (4) how to invoke the interpreter to run a given game
<i>and</i> immediately restore a given saved-game file, so that the
plug-in can be enhanced in the future to provide a saved-game browsing
and launch feature.

<p>The IFDB registry keys are under a common root:
\HKEY_CURRENT_USER\Software\IFDB.tads.org\MetaInstaller\Interpreters.
Each interpreter (or its installer) creates a sub-key of this key, with a name
chosen by the interpreter developer.  I recommend following the Java
style of domain-style naming so that we don't have to worry too much
about coordinating to avoid collisions.  For example, for HTML TADS
I'd use, say, htmltads.tads.org as my sub-key, so my full key would be
\HKEY_CURRENT_USER\Software\IFDB.tads.org\MetaInstaller\Interpreters\htmltads.tads.org.

<p>Under this interpreter-specific key, the interpreter installer
sets the following values:

<ul class=tight>
   <li>Version (String): the version string, of the form "x.y.z..."
   <li>RunGame (String): a command line to execute to run a game's
   story file, which is given as parameter "%1"
   <li>RunGameRestore (String): a command line to execute to run a game's
   story file (%1) and restore a saved game file (%2) immediately upon
   startup; this value is omitted if the interpreter doesn't support this
   feature
</ul>

<p>Each interpreter developer is responsible for these items:

<ul class=tight>
   <li>Select a sub-key name for your system
   <li>In your installer, add your registry key and set the required values
   <li>In your uninstaller, delete your registry key
</ul>


<h3>Tracking saved games</h3>

<p>It might be useful at some point for the Meta Installer to be able
to find saved position files.  The installer could use this to create
a more integrated "jukebox" experience for the player, by offering a
list of saved games when starting the game.

<p>We'll assume that saved games for each format can be identified by
their file extension, so we'll make this information available to the
Meta Installer, via an additional tag in the &lt;interpreter&gt;
section:

<p>
<pre>
  &lt;savedGameExtension&gt;<i>.extension</i>&lt;/savedGameExtension&gt;
</pre>

<p>Note that the "." at the start of the extension must be included.

<p>This element is optional - if the intepreter doesn't use a fixed
extension for saved games, this element should be omitted, as
extensions won't be useful as a way to identify these files.  This
element can appear more than once if the interpreter uses multiple
extensions for saved game files.  Note that only the extensions
relevant to the current format should be included for a multi-format
interpreter.  (For example, if an interpreter handles Z-Machine and
Hugo games, and it uses ".zsave" for Z-machine saved games and
".hsave" for Hugo saved games, the Hugo-specific &lt;interpreter&gt;
record should mention only the ".hsave" extension.)


<h3><a name="win_xml_summary"></a>Windows &lt;interpreter&gt; section
summary</h3>

<p>Putting all of the pieces together, here's what the full Windows
XML fragment for an &lt;interpreter&gt; section looks like:

<p>
<pre>
  &lt;interpreter&gt;
    &lt;name&gt;<i>name</i>&lt;/name&gt;
    &lt;version&gt;<i>version</i>&lt;/version&gt;
    &lt;registry&gt;<i>subkey name</i>&lt;/registry&gt;
    &lt;legacyinstall&gt;
      &lt;filetypekey&gt;<i>HKCR filetype key name</i>&lt;/filetypekey&gt;
      &lt;exename&gt;<i>terp filename.EXE</i>&lt;/exename&gt;
      &lt;exeMD5&gt;<i>MD5 hash value for terp .EXE file</i>&lt;/exeMD5&gt;
    &lt;/legacyinstall&gt;
    &lt;href&gt;<i>url</i>&lt;/href&gt;
    &lt;compression&gt;
      &lt;id&gt;<i>format ID</i>&lt;/id&gt;
      &lt;name&gt;<i>format name</i>&lt;/name&gt;
      &lt;primaryfile&gt;<i>filename</i>&lt;/primaryfile&gt;
    &lt;/compression&gt;
    &lt;action&gt;<i>action</i>&lt;/action&gt;
    &lt;RunGame&gt;<i>run-game command line</i>&lt;/RunGame&gt;
    &lt;RunGameRestore&gt;<i>run-and-restore command line</i>&lt;/RunGameRestore&gt;
    &lt;savedGameExtension&gt;<i>.extension</i>&lt;/savedGameExtension&gt;
  &lt;/interpreter&gt;
</pre>

<p>The name is a human-readable name, including the human-readable
version string; this is so that the UI can tell the user what needs
to be installed.

<p>The version is the machine-readable version string, in the format
"x.y.z..." (a minimum of one decimal integer optionally followed by
additional decimal numbers separated by periods; elements are in
decreasing order of significance).

<p>The "registry" value is the name of the interpreter's IFDB registry
sub-key, from the <a href="#new_terp_reg_keys">IFDB registry keys</a>
section.  This is not the full HKEY_CURRENT_USER\Software... string,
but just the final subkey name.  This is a domain-style name
identifying the interpreter and vendor, as in "htmltads.tads.org".

<p>The "href" gives the URL to the downloadable interpreter installer.
This can be an .EXE or .MSI installer, a .ZIP containing same, the
application itself as a raw .EXE file, or a .ZIP containing the
application .EXE and possibly other support files.  This URL must
point to the direct file download - it shouldn't point to an HTML page
that offers the file for download, for example.  The point is that the
Meta Installer will be able to do an HTTP GET (or equivalent for other
protocols) on this URL and save the returned content to obtain the
installer/ZIP/etc.

<p>The "compression" section is optional; it's only present if the
download target is compressed.  The format ID is one of the published
compression format IDs on IFDB: for ZIP files, this is "zip".  The
format name is a human-readable name describing the compression
format, for use in the client UI as needed.  The "primaryfile" value
gives the filename (using the relative path as stored in the ZIP file)
of the primary file within the ZIP.  In the case of an installer
program packaged within a ZIP, this is the name of the installer
program executable; in the case of an interpreter program that doesn't
have a separate installer, this is the name of the interpreter .EXE
file.

<p>The action code can be one of these:

<ul>
   <li><b>save</b>: there is no installer program; to install, simply save the
   file(s) (after unzipping, if applicable) to a new folder.  The interpreter
   program is the downloaded file itself, or the primary file unpacked
   from the compressed file.

   <li><b>run</b>: the downloaded program (the downloaded file itself, or the primary
   file if the downloaded file is a compressed archive) is an installer;
   to install, run this program.
</ul>

<p>The RunGame and RunGameRestore values give the values of the <a
href="#new_terp_reg_keys">IFDB registry keys</a> that the interpreter
normally sets up.  These values are the Windows command lines,
respectively, to invoke the interpreter to run a game, and to invoke
the interpreter to run a game with immediate restoration of a saved
game file.  In these values, %0 stands in for the name of the
interpreter (it's replaced with the full name, <b>including</b> the
full directory path), %1 stands in for the name of the game file to be
executed, and %2 stands in for the saved game file to be restored.
RunGameRestore is only specified if the interpreter supports the
run-and-restore operation.

<p>The RunGame, and RunGameRestore values allow the Meta
Installer to set the <a href="#new_terp_reg_keys">IFDB registry
keys</a> in lieu of the interpreter's installer doing so.  Normally,
we'd leave it to the interpreter's installer to do this work.
However, there are three cases where the Meta Installer has to set
these keys itself:

<ul>
   <li>When the action code is "save", there's no separate interpreter
   installer, so there's no one else to set the keys.

   <li>When the user has already installed the interpreter manually,
   and is using a version that predates the new keys, the Meta Installer
   can essentially "repair" the existing installation by first asking
   the user to identify the location of the interpreter executable,
   then plugging that into the RunGame and RunGameRestore to populate
   the corresponding registry keys.

   <li>For interpreters that are no longer supported, we probably won't
   be able to retrofit the IFDB registry key system, so the Meta Installer
   will have to do the work.
</ul>

<p><b>Syntax rules for RunGame and RunGameRestore</b>: These are
essentially DOS-style command lines.  Tokens are separated with
spaces; tokens that include spaces can be constructed by enclosing the
whole token in double quotes.  A double quote can be used within a
quoted token either by putting two quotes in a row, or by escaping the
quote with a backslash; other backslashes have no special meaning.
Take careful note that the executable name often contains spaces
because of the default "c:\Program Files" location on US-localized
systems, so these should usually be enclosed in double quotes to
ensure proper parsing.


<h3>Detecting "legacy" interpreter versions</h3>

<p>For our purposes here, a "legacy" interpreter is a version that
pre-dates the <a href="#new_terp_reg_keys">IFDB registry keys</a>.  The
new keys obviously weren't implemented by the versions of the various
interpreters that were already in distribution when the Meta Installer
came along, so if the Meta Installer is going to be able to detect
that an older version of one of these terps is installed, it needs
some means other than the IFDB registry keys.  

<p>Fortunately, there's an approach that happens to work for most of
the existing interpreters.  Most of the interpreters write keys to the
Windows registry to create associations between particular filename
suffixes (for example, ".gam" for a TADS 2 story file) and the
corresponding interpreter executables.  These associations let the
Windows shell launch the appropriate interpreter application when the
user double-clicks on a story file in Windows Explorer.  These
file-type association keys are stored in a standard way, so we can
exploit them to find interpreter executables.

<p>The &lt;legacyinstall&gt; element tells the Meta Installer how
to use one or more file-type associations to find a legacy version of
the interpreter.

<p>The &lt;legacyinstall&gt; element is optional.  The Meta Installer
uses it as a fallback, <b>only</b> when the key specified in the
&lt;registry&gt; element is <b>not</b> found.  If you don't specify
this element, the Meta Installer will simply assume that the
interpreter isn't installed if it can't be found using the IFDB
registry keys.  

<p>The &lt;filetypekey&gt; element gives the name of one file-type
association key that the interpreter creates under HKEY_CLASSES_ROOT.
This value gives the key name of the <b>abstract type</b> key for the
<b>story file</b> type that this interpreter handles.  Each Windows
file-type association has two elements.  The first is the concrete
extension key: this is a key of the form "HKCR\.xyz", where .xyz is a
file suffix; the (Default) value of such as a key is a string giving
the file type name.  For example, TADS sets the key "HKCR\.GAM", with
(Default) value "TADS.Game".  The second key is the abstract file type
key; it's called "HKCR\filetype", where filetype is the type name
referenced in the extension key, so in the case of TADS, this is
"HKCR\TADS.Game".

<p>The &lt;filetypekey&gt; value is just the key name.  <b>Don't</b>
include the HKCR\ prefix.  For example, the TADS 2 file type key is in
the registry as HKCR\TADS.Game, so the tag is written as
&lt;filetypekey&gt;TADS.Game&lt;/filetypekey&gt;.

<p>The &lt;filetypekey&gt; element may appear any number of times,
since some interpreters handle more than one story file type.

<p>The &lt;exename&gt; element gives the <b>base filename</b> of the
interpreter executable.  By "base" filename, we mean the filename
without any path information: so for HTML TADS, we'd specify
&lt;exename&gt;htmltads.exe&lt;/exename&gt;.  (The value isn't
case-sensitive, since the Windows file system isn't.)  The executable
name needs to be specified to differentiate among interpreters that
use the same file type keys - it helps ensure that the Meta Installer
is really detecting the right interpreter.

<p>The &lt;exeMD5&gt; gives the MD5 hash code for the current release
version of the interpreter executable.  If the Meta Installer finds a
candidate interpreter based on the file type association key and
executable filename, it computes the MD5 of the actual installed file,
and compares it with the value given here; if the values match, the
Meta Installer knows that the user has the current release installed.
If the values don't match, the Installer can offer to install the
latest version.  The &lt;exeMD5&gt; value is optional, but if it's not
provided, the Meta Installer will have no way of knowing if the
installer version is up to date.  The MD5 value is given in the
canonical printable format: 32 hex digits, with no embedded spaces or
hyphens.  Case is not significant.

<p>Here's an example of how the scheme is used.  The TADS 2 definition
looks like this:

<p><pre>
 &lt;legacyinstall&gt;
   &lt;filetypekey&gt;TADS.gam&lt;/filetypekey&gt;
   &lt;exename&gt;htmltads.exe&lt;/exename&gt;
   &lt;exeMD5&gt;4C874F7E5AD303412D20D02FFF0CCEA9&lt;/exeMD5&gt;
 &lt;/legacyinstall&gt;
</pre>

<p>The Meta Installer looks at HKCR\TADS.Game\shell\open\command, and
sees that this key exists and has default value <tt>"C:\Program
Files\TADS\htmltads.exe" "%1"</tt>.  The installer parses the value as
a command line and extracts the first token, which is <tt>C:\Program
Files\TADS\htmltads.exe</tt>.  The root filename from this token is
<tt>htmltads.exe</tt>, which matches the &lt;exename&gt; value.
The interpreter checks to see if the file exists, and if so computes
the MD5 hash of the file's entire binary contents, and compares the
result to the &lt;exeMD5&gt; value.  If the MD5 values match, the
installer knows that HTML TADS is installed and up to date.  If the
file is present but the MD5 values don't match, the installer offers
to install an update.  If the file or the registry keys are missing,
the installer assumes that HTML TADS is not installed.


<h3>Meta Installer maintenance</h3>

<p>We probably need a maintenance UI for the Windows Meta Installer -
a screen the user can bring up that lists the interpreters that we've
installed and lets them uninstall and reinstall them.


<h2>Meta Installer Security</h2>

<p>The nature of the Meta Installer makes it immediately suspicious as
a malware risk.  The program's purpose is to download and install
executable software.  Executables are by far the easiest way for
malicious developers to distribute malware, since they're essentially
unrestricted in accessing and modifying a computer's disk drives and
other resources.

<p>Unlike most web sites that use plug-ins, IFDB will <b>not</b>
attempt to install any plug-in automatically.  IFDB will only generate
HTML that displays the plug-in <i>after</i> the user has explicitly
asked to install the plug-in - this means that you'll never see a
browser security warning pop up from a game listing page about the
page needing a plug-in.  You'll either have the plug-in already, or
the page won't try to use it at all.  This makes the plug-in a purely
"opt-in" feature - users who aren't interested won't ever be bugged
about installing it.  For users who haven't installed the plug-in and
are using an OS/browser combination where a plug-in is available, IFDB
will display a link advertising the plug-in; the user can follow the
link to go to a separate page that explains what the plug-in does and
how to install it.

<p>Browser plug-ins are also notorious security risks.  Plug-ins are
risky because they allow web pages to invoke executable code on the
client.  This is problematic because users are accustomed to being
able to trust the browser to "sandbox" web pages enough that there's
little risk in just visiting an arbitrary web site.  Plug-ins
essentially bypass this sandboxing by giving web pages a way to invoke
client-side executable code outside of the browser.

<p>The main risk with plug-ins isn't that the whole idea is bad, or
that the plug-in architecture itself is risky.  Rather, the problem is
that a plug-in is just native executable code, so the full burden of
responsibility to make the plug-in secure is on the plug-in's
developer.  In contrast, scripts and applets and the like are
restricted by the browser, so a careless applet or script developer
can make all kinds of mistakes and still be saved by the security
measures in the browser.  A plug-in developer is completely on her own
to make the plug-in secure.  Any mistakes or omissions can compromise
system security because the plug-in isn't restricted by the browser's
security measures.

<p>There are several things we do in the Meta Installer design to
reduce the security risks.  Some of this is in the overall
architecture of the system, and some is in the individual plug-ins.

<h3>Architectural Security Features</h3>

<p>The following elements of the system architecture are designed to
enhance security of the Meta Installer.  These are features of the
whole system, so they apply to every plug-in, regardless of its
internal implementation details.

<ul>

   <li>The plug-in <b>never</b> takes its download instructions from
the information in a web page.  It's not possible for a malicious web
page to feed the plug-in bad installation information, because it's
simply not possible for any web page to feed it any installation
information at all.

   <li>The <b>only</b> information that a web page passes to the
plug-in is an ID string of the game to be installed.  This ID string
contains no URL information - it's simply a <a
href="http://ifdb.tads.org/help-tuid">TUID</a>, which is an
alphanumeric serial number identifying the game in the database.  This
number has no meaning to a web browser or any network software, so
it's not possible to use a spoofed TUID to misdirect the plug-in to a
non-IFDB site.

   <li>The plug-in takes the TUID and sends it to the IFDB
site to request the install plan.  The IFDB URL is hard-coded into the
plug-in - there's no way for a web page to feed a bad URL to the
plug-in to trick it into requesting information from a different site.

   <li>The plug-in should make its network requests <b>directly</b>
through the operating system's network APIs.  (This is up to the
plug-in developers to do correctly, but it should be straightforward
on any OS.)  This means that the web page that invoked the plug-in
isn't involved in any way with the plug-in's communications with the
IFDB server.  This makes it impossible for the web page to use a
script or other technique to misdirect the plug-in's communications.
The only way that the web page could misdirect the plug-in's request
is to take over the user's network stack at the OS API level.  If an
attacker is capable of doing this, they already have such complete
control of the computer that there's nothing further to gain from
hijacking an IFDB plugin.

   <li>The actual download instructions are returned from the IFDB
site in response to the plug-in's request.  The IFDB site calculates
the instructions based entirely on the game identification (the TUID)
and OS identification that the plug-in sent in its request.  The only
way for the originating web page to feed information back to the
plug-in is in the form of the game TUID, since that's the only
parameter.  If the web page did try to feed a bad TUID to the plug-in,
that bad TUID would simply get passed along to the server.  The TUID
is nothing more than a serial number, and doesn't encode any other
information internally, so a corrupted TUID will either be found in
the database or it won't:

   <ul>

      <li>If a malicious web page passes a bad TUID
      that doesn't match any game in the database, the server will simply
      report an error to the plug-in, so no installation will be attempted.

      <li>If the page passes a bad TUID that happens to match a game
      in the database, the server will send installation instructions for
      that game.  They'll be perfectly valid instructions to install that
      game.  It might not be a game that the user wanted to install,
      which is why the plug-in should always prompt for confirmation
      before proceeding with an install.  This way, the extent of the
      damage from a "bad TUID attack" would be a spurious prompt to
      install an unwanted game.

      <li>A malicious web page could also try various parameter
      attacks that don't try to abuse the TUID per se but simply try to
      exploit common bugs that can be triggered by passing in bad
      parameter data:  buffer overruns, SQL escapes, etc.  It's up to
      the plug-in developer to use good security practices to handle these
      common attacks, and it's up the IFDB developers to protect the server
      against them.  It's relatively easy to repel these attacks if you're
      paying attention to them when you write the code.  We develop the
      server software with an awareness of these sorts of attacks and try to
      ensure it's secure against them.

   </ul>

<li>Since the installation instructions come directly from the IFDB server,
a bad guy would have to put malicious instructions on the IFDB server
in order to pass them to a client machine.  Access to the tables that
store the format- and OS-specific installation instructions is
restricted to authorized users, as described <a
href="#tableMaintenance">below</a>.  The IFDB policy is to authorize
only a few trusted experts to edit these tables.  

</ul>

<h3>Plug-In Security Measures</h3>

<p>Some security measures must be implemented individually in
each plug-in:

<ul>

   <li>Each plug-in developer should observe general secure coding
practices, as well as the particular security guidelines for the
target browser.  Use good coding practices to avoid well-known attacks
(e.g., buffer overrun attacks).  Since the system architecture calls
for such a simple interface between the plug-in and the enclosing web
page, the available avenues for attack are very limited, and it should
be relatively straightforward for competent developers to assess and
secure the interfaces.

   <li>Plug-in authors are strongly encouraged to make the source code
to each plug-in available to end users for inspection.  This will
let sophisticated users help improve security by independently
looking for errors, and will reassure users that there's nothing
malicious hidden in the plug-in itself.

   <li>Plug-ins should never do any installation work without the
user's express permission.

   <li>If possible, the plug-in should verify that the browser is
displaying a page within the ifdb.tads.org site.  This should largely
eliminate the possibility that a malicious web site could re-purpose the
plug-in to install a malicious game program - if a non-IFDB site can't
invoke the plug-in at all, it can't use it to install anything
malicious.

   <li>Plug-ins should be relatively transparent in informing the user
of the work to be done, particularly when executable code will be
downloaded, and particularly when downloaded code will be executed as
part of the installation process.

   <li>All of the plug-in's user interaction, particularly to seek
permission, should be through an independent UI that goes directly
through OS APIs and <b>not</b> through the browser.  This is important
because it ensures that a malicious web page can't spoof a user
interaction through scripting.  

</ul>



<h2><a name="tableMaintenance">DLA Instructions Table Maintenance</a></h2>

<p>One of the key design elements of IFDB is that the game entries are
open to public editing, along the lines of Wikis.  This design is an
attempt to immunize IFDB against a chronic problem among IF reference
sites (and the web in general, really): our reference sites tend to
slip out of date because they get only sporadic attention from their
owners.  By opening up the site to allow users to make updates, the
site will be as up to date as its users want it to be - if a user
sees something that's out of date, she can simply fix it herself
rather than waiting for the site's owner to get to it.

<p>It's even more important to keep the DLA instructions up to date.
If they ever become obsolete - especially if the download URLs they
contain are broken - the Meta Installer will cease to function, and
the DLA instructions will be misleading.

<p>There are too many operating systems and interpreter in use today
for any one person to be an expert in all of them.  That, coupled with
the basic risk of sporadic attention, makes it clear that we don't
want the site's owner to be a bottleneck for maintaining the DLA
tables.  Clearly, we need to distribute the responsibility.

<p>On the other hand, it would be a bad idea to make the DLA tables
open to the public for editing, the way game entries are.  The problem
is that the DLA entries contain instructions for downloading and
installing executable programs.  If users are going to trust the DLA
and the Meta Installer, it's vitally important that the sources of the
download instructions be protected.  If anyone could edit the tables,
a bad guy could easily set a download link for an interpreter to point
to malware.

<p>To balance these needs - distributing the maintenance
responsibilities vs. protecting the tables against malicious updates -
IFDB is set up so that access to the DLA tables is restricted to
authorized users.  The system makes it possible to grant DLA access to
specific users on the basis of their format or OS expertise.

<p>So our plan is that the DLA entries will be maintained by a small
group of trusted individuals.  We'll seek to cover all of the formats
and operating systems this way.  Ideally, we'll be able to enlist the
chief developer for each of the main format interpreters, which should
cover most of the bases.  Enlisting interpreter developers is the best
way to ensure timely updates - ideally, updating IFDB's DLA entries
would become a routine part of each interpreter's release process.

<p>
<hr>
<p>
<!------------------------------------------------------------------------>
<h1>Footnotes</h1>

<p><a name="footnote1"></a><a href="#returnnote1"><b>[1]</b></a>
In terms of the real-world entities involved, it would arguably be
better to treat each operating system's executables as separate
formats: we'd have Windows Executable, Macintosh Executable, etc.
That's a better mapping to actual file formats, since "Windows
executable" and "Macintosh executable" are file formats in exactly the
same sense that JPEG, GIF, MP3, and "Word Document" are: "Windows
executable" is a particular way of laying out bytes in a file to
represent a composite data structure, in this case a program that
executes on Windows.

<p>We chose not to go that route for a couple of practical reasons.
First, we need to distinguish not only operating systems, but OS
versions, since many OSes have multiple releases in circulation, with
varying degrees of compatibility.  Including all of the OS versions in
the file format list would have made the list too long for comfort in
the UI.  Second, we need a separate list of operating systems anyway,
since we need a way for the user to identify which OS they're using.
If we had separate "Exectuable for X" types, we'd have to correlate
those with the entries in our OS list.  The data model is better
normalized if we treat the OS and file type as orthogonal entities.

<p><a name="footnote2"></a><a href="#returnnote2"><b>[2]</b></a>
For example, a Word .doc file can be viewed on any platform with
software that reads the .doc format.  In the case of Word, actually,
there are numerous incompatible sub-formats: Word 97, Word 2000, etc.
If it were necessary to use different viewer apps with the different
sub-formats, we'd handle this by defining separate file types for the
sub-formats.

<p><a name="footnote3"></a><a href="#returnnote3"><b>[3]</b></a>
We look for records tied to OS versions less than or equal to the
target OS version because we assume backward compatibility for new
versions of the operating system.  We <i>don't</i> assume upward
compatibility for applications.  That is, we assume that an app
designed for version N of a given OS will run on the OS versions N+1,
N+2, etc.  However, we don't assume that an app designed for version N
of the OS will run on version N-1, since the app might depend upon new
OS features that were introduced in version N.  This type of backward
compatibility isn't guaranteed, but it's usually the case.  For
particular applications that don't migrate to newer versions beyond a
given point, we assume that the app developer will create a new
version of the app for the new OS, at which point we'd simply
introduce a separate Instructions record for that OS version pointing
to the new app version: our algorithm ensures that users with the
older OS will still pick up the older app version, and users with the
newer OS will get the newer app version.  When backward compatibility
is significantly broken across the board by a new OS version, we
handle this by branching off the new OS version as a whole separate
OS; we do this with Mac OS X vs Mac OS 7/8/9.

<p><a name="footnote4"></a><a href="#returnnote4"><b>[4]</b></a>
As an example of how this works, let's look at the Windows/Internet
Explorer case.  The plug-in for this target browser is implemented as
an ActiveX control, because that's IE's primary plug-in mechanism.
When IFDB detects the Internet Explorer browser on Windows, it inserts
some scripting code into the generated page that uses vbscript
techniques to detect whether the user has the IFDB ActiveX plug-in
installed.  If the scripting code's test determines that the plug-in
is indeed present, the script injects an &lt;OBJECT&gt; tag into the
page.  The &lt;OBJECT&gt; tag is the IE mechanism for instantiating an
ActiveX object, so this fires up the plug-in.  The &lt;OBJECT&gt; tag
contains a a &lt;PARAM&gt; tag that passes the TUID of the game being
viewed to the plug-in.  The script code further injects the "Play Now"
button as an &lt;IMG&gt; tag with an "onscript" javascript event
handler that invokes the plug-in's main entrypoint, which is what
initiates the installation process.

<p><a name="footnote5"></a><a href="#returnnote5"><b>[5]</b></a>
For example, the Windows/IE ActiveX plug-in uses a &lt;PARAM&gt; tag
to pass this value to the plug-in when instantiating the ActiveX
object.

<p><a name="footnote6"></a><a href="#returnnote6"><b>[6]</b></a>
Note that IFIDs were also designed to have the same properties
(stability, global uniqueness), so we could use the IFID list for this
purpose instead.  However, IFIDs aren't guaranteed to be single-valued
(a particular game can have several, and a future version will have a
new IFID if the author doesn't know about the Babel architecture or
doesn't bother to use it); this multi-valued property makes IFIDs a
bit more work for the client component to manage.  In addition, IFIDs
could conceivably be entered into the database incorrectly and then
later revised, whereas TUIDs are assigned automatically by IFDB and so
aren't subject to revision.  Finally, IFDB doesn't currently require
game listings to include IFIDs, so some games in the database might
not include IFID values at all.

<p><a name="footnote7"></a><a href="#returnnote7"><b>[7]</b></a> For
HTML TADS on Windows, and probably for most apps that incorporate
Uninstall programs, you can tell that the application is installed by
checking for the presence of the standard Windows uninstall registry
key - in HTML TADS's case, this is
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\htmltads.exe\UninstallString.
This tells us (a) that the application is installed, and (b) with some
work, where to find the interpreter program.  The trick with (b) is
that we have to parse the value of the key to pull out the
command-line argument, which tells us the directory where the
uninstall data file is located, which also happens to be the base
install directory.  We can then form the full path to the interpreter
by combining the directory path from this uninstall string with the
name of the interpreter .EXE file.  With this in hand, we have or can
synthesize nearly all of the information we're after - the one thing
we're missing is the version information.  For that, I don't think
there's any good solution; probably the only thing we could do would
be to calculate an MD5 hash of the .EXE file, and assume that a
mismatch with the server version's MD5 hash means that we have an old
version.

<p>Assuming we wanted to use an approach like this, we'd have to come
up with a way to encode it in the XML instructions, to tell the Meta
Installer what to look for.  Something like this:

<p>
<pre>
&lt;existingversion&gt;
  &lt;directory&gt;
    &lt;registry&gt;
      &lt;key&gt;
        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\htmltads.exe
      &lt;/key&gt;
      &lt;item&gt;
        UninstallString
      &lt;/item&gt;
      &lt;parse&gt;
        *\TADSUINS.EXE $\UnInst*.inf
      &lt;/parse&gt;
    &lt;/registry&gt;
  &lt;/directory&gt;
  &lt;file&gt;
    htmltads.exe
  &lt;/file&gt;
  &lt;version&gt;
    &lt;md5&gt;A5C729910177F7AE97B00F28&lt;/md5&gt;
  &lt;/version&gt;
&lt;/existingversion&gt;
    
</pre>

<p>The idea is that the registry string is parsed by matching the
"parse=" template, such that "*" matches arbitrary text, "$" matches
arbitrary text <i>that becomes the result of the parse</i>, and
everything else is matched literally.  The result of the parse is then
used as though it were the contents of the &lt;directory&gt; tag, so
this is combined with the &lt;file&gt; tag to form the name of the
executable.  The "md5" value means that we can compare
versions by computing the MD5 hash of the interpreter executable and
checking to see if it matches the value given.

<p>This is all awfully hacky; the question is whether something like
this would generalize to the other interpreters.  We obviously can't
have a completely separate approach for each system; we need something
that we can parameterize so that it's readily extensible to additional
systems without requiring updates to the Meta Installer itself.

<p><a name="footnote8"></a><a href="#returnnote8"><b>[8]</b></a>
What I have in mind is a UI something like this:

<ul>
   <li>The user clicks "Play It Now" to play a game

   <li>The Meta Installer queries the server to determine what interpreter
   is needed.  It then pops up its main screen:

   <blockquote>
   <p>To play this game, you need to install the HTML TADS Interpreter
   (version Win115).
   <ul class=tight>
      <li>(Radio button) Automatically install from the Web
      <li>(Radio button) I've already installed this program
   </ul>
   (OK/Cancel)
   </blockquote>

   <li>If the user chooses "Automatically install," we proceed with a new
   installation.
   
   <li>If the user picks "I've already installed it," we go to another
   screen:

   <blockquote>
      Please select the TADS Interpreter executable<br>
      (file selector, filtered for .EXE files, starts in Program Files)
   </blockquote>

   <li>If the user picks out an interpreter, we record it in our
   database as though we'd downloaded and installed it ourselves.
   Since the user is explicitly declining to download the current
   version, we'll record the current version as indicated in the
   XML data as what the user has installed.  This will ensure
   that we'll ask again when the next update is available, but
   we won't bother the user until then.

</ul>

<p><a name="footnote9"></a><a href="#returnnote9"><b>[9]</b></a>
Which compression formats is a Meta Installer expected to support?

<p>Since most story files are widely portable, and since the compilers
for most formats are also widely ported, it's possible in principle
for a story file to use any compression format - including formats
that aren't commonly used on the Meta Installer's native platform.
For example, a Windows user might encounter a game packaged with
StuffIt, since the game's author might have been working on a
Macintosh.

<p>In practice, though, ZIP is by far the most common format on the IF
Archive, so a Meta Installer that supports ZIP will handle most of the
games in the Archive.  Virtually the only other formats that appear
among games written in the last ten years are .tar.gz and .tar.Z.  If
you handle ZIP, .tar.gz, and .tar.Z, you'll handle virtually
everything in the Archive.  There are other files in formats on the
Archive, but they're hardly ever used for portable files.  There are a
lot of old native Amiga games in .LHA format; and Mac-native games are
usually packaged in StuffIt format.  None of these are usable on other
OSes, though, so a Meta Installer for another platform should never
encounter them.

<p><a name="footnote10"></a><a href="#returnnote10"><b>[10]</b></a>
Note that there's a problem with game installers on Windows: the Meta
Installer will have no idea of how to execute the game itself, since
it will only know how to execute the installer.  The Windows Meta
Installer might simply disallow this type of download.

</body>
</html>
